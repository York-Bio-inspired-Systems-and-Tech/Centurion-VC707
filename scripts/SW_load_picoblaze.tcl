#puts -nonewline "updatemem --force --meminfo centurion_VC707.mmi "
#for {set i 0} {$i < 64} {incr i} {	
#	puts -nonewline "--data $intel_filename "
#}
#for {set i 0} {$i < 64} {incr i} {	
#	puts -nonewline "--proc intel_${i} "
#}
#puts "--bit pcie_bd_wrapper.bit --out download.bit"

set NUM_NODES 64


if {[info exists mem_filename] == 0} {
    puts "ERROR: mem_filename not set"
    return
}

if {[info exists BRAM_LENGTH_WORDS] == 0} {
    puts "ERROR: BRAM_LENGTH_WORDS not set"
    return
}

if {[info exists BRAM_inst_name] == 0} {
    puts "ERROR: BRAM_inst_name not set"
    return
}

puts "Loading  picoblaze code to $BRAM_inst_name"

puts "Reading file $mem_filename for BRAM population"
set fp [open $mem_filename r]
set file_data [read $fp]
close $fp

set data [split $file_data "\n"]
#remove all whitespace generated entries
set data [lsearch -all -inline -not -exact $data {}]
#remove first element from list (this is the start at address 0 @00000 directive)
set data [lreplace $data 0 0]
set data_len [llength $data] 

puts [lindex $data 0]

#check list length against BRAM length
if { $data_len != $BRAM_LENGTH_WORDS} {
    puts "ERROR: MEM file is $data_len words but BRAM is $BRAM_LENGTH_WORDS words."
    puts "Only one @addr at 0000 is allowed in the .mem file as generated by OPBASM"
    return
}

#generate the variables needed to calculate the length of the byte lanes and the parity lanes.
set RAM_INIT_WIDTH_BITS 256
set NUM_INITS [expr { $BRAM_LENGTH_WORDS / ($RAM_INIT_WIDTH_BITS / 16)}] 
puts "$NUM_INITS INITs required"
set NUM_INITPS [expr {$NUM_INITS /8}]
puts "$NUM_INITPS INITPs required"



set inits {}
set mem_index 0

#build the INITS
for {set i 0} {$i < $NUM_INITS} {incr i} {
    set init_string {}
    for {set j 0} {$j<$RAM_INIT_WIDTH_BITS / 16} {incr j} {
	set byte [lindex $data $mem_index]
	set byte [string range $byte 1 4]
	set init_string $byte$init_string
	incr mem_index
    }

    lappend inits $init_string
    
}

puts $inits

#build the INITPs

set initps {}
set mem_index 0

for {set i 0} {$i < $NUM_INITPS} {incr i} {
    set init_string {}
    for {set j 0} {$j<$RAM_INIT_WIDTH_BITS / 2} {incr j} {
	set parity_2_bit [lindex $data $mem_index]
	set parity_2_bit [string range $parity_2_bit 0 0]

	if { $j % 2 == 0} {
        set nibble $parity_2_bit
	} else {
	    set parity_2_bit_lsh [expr $parity_2_bit << 2]
	    set nibble [expr $nibble | $parity_2_bit_lsh]
	    set nibble [format %x $nibble]
	    set init_string $nibble$init_string
	}
	incr mem_index
	#puts $init_string
    }
    lappend initps $init_string
}

puts $inits
puts $initps

#write the INITs and INITPs into the BRAMs.
set BRAM_filter  " PRIMITIVE_TYPE == BMEM.BRAM.RAMB18E1 && NAME =~  \"*$BRAM_inst_name*\""
set BRAM_list [get_cells -hierarchical -filter $BRAM_filter]

puts $BRAM_list

#set the INIT strings
foreach BRAM_inst $BRAM_list {
    puts $BRAM_inst

    for {set i 0} {$i < $NUM_INITS} {incr i} {
	set i_hex [format %x $i]
	if {[string length $i_hex] == 1} {
	    set init "0${i_hex}"
	} else {
	    set init $i_hex
	}

	set init_string [lindex $inits $i]
	set exec_string "set_property INIT_$init 256'h$init_string \$BRAM_inst"
#	puts $exec_string
	eval $exec_string

    }

    #set the INITP strings

    for {set i 0} {$i < $NUM_INITPS} {incr i} {
	set i_hex [format %x $i]
	if {[string length $i_hex] == 1} {
	    set init "0${i_hex}"
	} else {
	    set init $i_hex
	}

	set init_string [lindex $initps $i]
	set exec_string "set_property INITP_$init 256'h$init_string \$BRAM_inst"
#	puts $exec_string
	eval $exec_string
    }
}
